Symfony model
=============

Overview
--------

Symfony has an object/relational abstraction layer based on the [Propel][1] project. Accessing data stored in a database and modifying it is made easy through an object translation of the database. This chapter explains the creation of such an object data model, the way to access and modify the data in Propel. It also illustrates the integration of Propel in Symfony.

Why use an abstraction layer?
-----------------------------

Databases are relational. PHP5 and symfony are object oriented. In order to access the database in an object-oriented way, an interface translating the object logic to the relational logic is required. It is called an object-relational mapping, or ORM. 

This is the **Model** layer of the symfony MVC architecture. It is made up of objects that give access to data and keep business rules within themselves.

One benefit of an object/relational abstraction layer is that it prevents you from using a syntax that is specific to a given database. It automatically translates calls to the model objects to SQL queries optimized for the current database.

This means that switching to another database system in the middle of a project is easy. Imagine that you have to write a quick prototype for an application, but the client hasn't decided yet which database system would best suit his needs. You can start building your application with SQLite, for instance, and switch to MySQL, PostgreSQL or Oracle when the client is ready to. Just change one line in a configuration file, and it works.

An abstraction layer encapsulates the data logic. The rest of the application doesn't need to kow about the SQL queries, and the SQL that accesses the database is easy to find. Developers who are specialized in database programming also know clearly where to go.

Using objects instead of records, and classes instead of tables, have another benefit: They allow you to add new accessors to your tables. For instance, if you have a table called 'Client' with two fields 'FirstName' and 'LastName', you might like to be able to require just a 'Name'. In an object-oriented world, it is as easy as adding a new accessor method to the `Client` class.

    [php]
    public function getName()
    {
      return $this->getFirstName.' '.$this->getLastName();
    }

All the repeated data access functions and the business logic of the data itself can be kept in such objects. Imagine a class 'ShoppingCart' in which you keep items (which are objects). To get the full amount of the shopping cart for the checkout, you can add the following method:

    [php]
    public function getTotal()
    {
      $total = 0;
      foreach ($this->getItems() as $item)
      {
        $total += $item->getPrice();
      }
      return $total;
    }

And that's it. Imagine how long it would have required to write a SQL query doing the same? 

[Propel][1] is currently one of the best object/relational abstraction layer for PHP5. Instead of rewriting it, symfony integrates it seamlessly into the framework.

XML Data model 
--------------

### Purpose

In order to create the data object model that PHP can use, you need to translate whatever relational model your database has to an object data model. Propel does that with an XML format file called `schema.xml`.

The `schema.xml` file must be located in the `myproject/config/` directory. This implies that all applications of your project will share the same data object model.

When you create an application with the `symfony init-app` command, a file called `schema.xml.sample`, containing the first lines of a `schema.xml`, is provided as a sample in the same directory (feel free to erase it as soon as your own schema is written):

    [xml]
    <?xml version="1.0" encoding="UTF-8"?>
     <database name="propel" defaultIdMethod="native" noxsd="true">
     </database>

The `name` attribute of the `<database>` tag is the name of the database connection. It is not the actual name of your database, because this name depends on the application configuration - and the environment - that you will describe in the database connection configuration file (`myproject/apps/myapp/config/databases.yml`).

>**Note**: As a matter of fact, you can setup several database connections for one project, to be able to dispatch your data into several databases. To that extent, you can either write several `schema.xml` files (prefix them with a special name, but keep the `schema.xml` at the end so that they are recognized) or add other `<database>` tags to your `schema.xml` file.

### Example

Now, let's imagine that you have a database 'blog' already containing data in two tables: 'blog_article' and 'blog_comment' with the following structure:

  | blog_article | blog_comment |
  | ------------ | ------------ |
  | id           | id           |
  | title        | article_id   |
  | content      | author       |
  |              | date         |
  |              | content      |

The related `schema.xml` should look like:

    [xml]
    <?xml version="1.0" encoding="UTF-8"?>
     <database name="propel" defaultIdMethod="native" noxsd="true">
        <table name="blog_article" phpName="Article">
          <column name="id" type="integer" required="true" primaryKey="true" autoIncrement="true" />
          <column name="title" type="varchar" size="100" />
          <index name="title_index">
            <index-column name="title"/>
          </index>
          <column name="content" type="longvarchar" />
        </table>
        <table name="blog_comment" phpName="Comment">
          <column name="id" type="integer" required="true" primaryKey="true" autoIncrement="true" />
          <column name="article_id" type="integer" />
          <foreign-key foreignTable="blog_article">
            <reference local="article_id" foreign="id"/>
          </foreign-key>
          <column name="author" type="varchar" size="50" />
          <column name="date" type="timestamp" />
          <column name="content" type="longvarchar" />
        </table>    
     </database>

Notice that the name of the database itself (`blog`) doesn't appear in the `schema.xml`. It will be specified in the connection configuration (see the `databases.yml` below).

### Format description

In a `schema.xml`, a `<database>` contains several `<table>` tags, each having a set of `<column>`, `<index>` and `<foreign-key>` in no particular order.

The `phpName` given to the table is the name of the object that will give you access to the data, as you will see in the next part. If you don't mention it, the value of the `name` attribute will be used in place, after removing underscores and capitalizing the first letter of inner words (in the example, the default `phpname` of the tables would be `blogArticle` and `blogComment`). Columns also have a `phpName`, which is the capitalized version of the `name` (`ID`, `TITLE`, `CONTENT`, etc.) and doesn't need overriding in most cases.

Columns have a `type` attribute that can take the usual values: `boolean`, `integer`, `float`, `date`, `varchar`, `longvarchar`, etc. The `varchar`-type columns can have a `size` attributes that specifies the maximum number of characters of the column. For text content over 256 characters, you need to use the `longchar` type, which has no size but can not exceed 65Kb (mysql specific). Note that the `date` and `timestamp` types have the usual limitations of Unix dates and can not be set to a date prior to 1970-01-01. As you may need to set older dates (for instance for dates of birth), a format of dates 'before Unix' can be used with `bu_date` and `bu_timestamp`.

The `primaryKey` attribute identifies primary key fields. Columns that are primary keys often have the same attributes (`type="integer" required="true" autoIncrement="true"`). If you need to create an index, simply add an `<index>` tab. If you need to create a foreign key, simply add a `<foreign-key>` tag identifying the corresponding column in a foreign table with the `<reference>` tag.

To learn more about this file format and its specifications, refer to the [documentation][2] and the [getting started][3] sections of the Propel project website. 

Object data model files
-----------------------

### Generation

Now that the object data model is described, the PHP classes are ready to be generated. In your project directory, type the command:

    $ symfony propel-build-model

>**Note**: Propel uses [Phing](http://phing.info/trac/) at this point, so you will need to install it if it wasn't done already by calling:
>
>     $ pear install http://phing.info/pear/phing-current.tgz

The base data access classes will be automatically created in the `myproject/lib/model/om/` directory:

    BaseArticle.php 
    BaseArticlePeer.php 
    BaseComment.php
    BaseCommentPeer.php 

In addition, the actual data access classes will be created in `myproject/lib/model`:

    Article.php 
    ArticlePeer.php 
    Comment.php
    CommentPeer.php 

You only defined two tables and you end up with eight files. What's the deal here?

### Base and current model 

Why keep two versions of the data object model, one in `model/om/` and another in `model/`? 

You will probably need to add custom methods and attributes to the model objects (think about the `->getName()` method that outputs the `FirstName` and `LastName` together). But as your project develops, you will also add tables or columns. Whenever you change the `schema.xml`, you have to make a new call to `symfony propel-build-model` to generate the object model classes.

The `Base` architecture allows you to keep using the `symfony propel-build-model` command even after you added custom code to your classes. Here is how it works: the `Base` classes kept in the `model/om/` directory are the ones generated by Propel. You should **never** modify them since every new build of the model will completely erase these files. But if you need to add custom methods, use the regular object classes of the `model/` directory that actually inherit from the previous ones.

For example, here is the content of the newly created `Article.php` file:

    [php]
    require_once 'model/om/BaseArticle.php';
    class Article extends BaseArticle
    {
    }

It inherits all the methods of the `BaseArticle` class, but a modification in the model will not affect it. This structure is both customizable and evolutionary.

This mechanism allows you to start coding even without knowing the final relational model of your database.

### Peer classes

The classes `Article` and `Comment` will allow you to access attributes of a record of the related tables. This means that you will be able to know the title of an article by calling a method of an `Article` object:

    [php]
    $article = new Article();
    ...
    $title = $article->getTitle();

 But there is more to databases than reading what's inside records: you also need to actually find records. That's the purpose of the `Peer` classes. They offer class methods to find records, that return an object or a lists of objects of the related 'no `Peer`' class.
 
    [php]
    $articles = ArticlePeer::doSelect(new Criteria());
    // $articles is an array of objects of class Article

From a data model point of view, note that there cannot be any `Peer` object. That's why the methods of the `Peer` classes will be called with a `::` (for class method call) instead of the usual `->` (for object method call).

Database access configuration
-----------------------------

The data model is independent from the database used, but you will definitely use a database. The minimum information required by symfony to handle requests to the project database is the name, the access codes and the type of the database. This data should be entered in the `databases.yml` file located in the `myproject/config/` directory:

    prod:
      propel:
        param:
          host:               mydataserver
          username:           myusername
          password:           xxxxxxxxxx  
    
    all:
      propel:
        class:                sfPropelDatabase
        param:
          phptype:            mysql
          host:               localhost
          database:           blog
          username:           root
          password:           
          compat_assoc_lower: true
          # datasource:       propel

The database access is environment dependant. You can define different settings for the `prod`, `dev`, `test` environments, or any other environment you defined. The `all` header defines settings for all environments. This configuration can also be overridden per application, by setting different values in an application-specific file, for instance in `myproject/apps/myapp/config/databases.yml`.

For each environment, you can define many connections, each being linked to a `schema.xml`. Connections and schema are linked by the `datasource`  parameter. It refers to the `name` attribute of the `<database>` tag in the `schema.xml`. If you don't specify the `datasource` param, it takes the value of the label given to the connection settings.

The permitted values of the `phptype` parameter are the ones of the database systems supported by Propel:

* mysql
* sqlserver
* pgsql
* sqlite
* oracle

The `host`, `database`, `username` and `password` settings define the parameters required to connect to the database.

In the above example, the settings for `all` environments can also be written using the shorthand syntax:

    all:
      propel:
        class:          sfPropelDatabase
        param:
          dsn:          mysql://root:@localhost/blog

>**Note**: If you use a SQLite database, the `host` parameter has to be set to the path to the database file. For instance, if you keep your blog database in `myproject/data/blog.db`, the `databases.yml` will look like:
>
>     all:
>       propel:
>         class:          sfPropelDatabase
>         param:
>           dsn:          sqlite://./../data/blog.db 
> 

Don't create the model twice
----------------------------

### Building a SQL database structure based on an existing schema

If you start your application by writing the `schema.xml`, you might not want to do it a second time in SQL to actually create the tables in the database. Symfony can generate a SQL query that creates the tables directly from the XML data model. To get it, go to your root project directory and type:

    $ symfony propel-build-sql

A `schema.sql` will be created in `myproject/data/sql/`. Note that the generated SQL code will be optimized for the database system defined in the `phptype` parameter of the `databases.yml` file. You can also precise the connection that you want to use. For instance, if you have a `databases.yml` in your `myapp` application defining settings for the `propel` connection in the `prod` environment:

    $ symfony propel-build-sql myapp prod propel

You can use the `schema.sql` directly to build the tables. For instance, in MySQL:

    $ mysqladmin -u root -p create blog
    $ mysql -u root -p blog < data/sql/schema.sql

This command is also helpful to rebuild the database in another environment, or to change RDBMS. 

>**Note**: If the connection settings are properly defined in your `databases.yml`, you can even use the `symfony propel-insert-sql` command to do this automatically.

### Generating an XML data model from an existing database

Symfony can use the Creole database access layer to generate a `schema.xml` from an existing database, thanks to introspection. This can be particularly useful when you do reverse engineering, or if you prefer working on the database before working on the object model.

In order to do this, you have to make sure that the project `databases.yml` points to the correct database and contains all connection settings.

You can call the `propel-build-schema` command:

    $ symfony propel-build-schema
    
And a brand new `schema.xml` built from your database structure is written in your `myproject/config/` directory. Once again, you can determine the connection to use if there is an alternative:

    $ symfony propel-build-schema myapp prod propel

Data access
-----------

In Propel, your data is accessed through objects. If you are used to the relational model, and to SQL to retrieve and alter your data, the Propel methods will probably look complicated. But once you've tasted the power of object orientation for data access (have a look at the [examples](http://propel.phpdb.org/trac/wiki/Users/Documentation/BasicCRUD) given in the Propel documentation), you will probably like it a lot. 

### Field access

Propel provides one class for each the tables defined in the `schema.xml` file. These classes have default creators, accessors and mutators: The `new`, `get` and `set` methods give access to the columns of the table.

    [php]
    $article = new Article();
    $article->setTitle('My first article');
    $article->setContent('This is my very first article.\n Hope you enjoy it!');
    
    $title   = $article->getTitle();
    $content = $article->getContent();

Note that the `phpName` attribute of the `table` is used for the class name; the accessors use a [CamelCase][6] variant of the column names in which the first letter of each word is capitalized and underscores are suppressed.

To set several fields at one time, you can use the `->fromArray()` methods of the Propel objects:

    $article->fromArray(array(
       'title'   =>   'My first article',
       'content' =>   'This is my very first article.\n Hope you enjoy it!',
    ));

To create a record in a table related to another, simply pass the object as a foreign key:

    [php]
    $comment = new Comment();
    $comment->setAuthor('Steve');
    $comment->setContent('Gee, dude, you rock: best article ever !');
    $comment->setArticle($article);

The last line automatically sets the `ArticleId` attribute of the `Comment` object to the value of the `Id` attribute of the `Article` object. Of course, you could have done it manually:

    [php]
    $comment->setArticleId($article->getId());

Note that by calling the `new` constructor, you created a new object but not an actual record in the `Article` table. In order to save the data into the database, you need to `save()` your object:

    [php]
    $article->save();

The cascading principle of Propel exempts you from also saving the `$comment` object: As the record is linked to the one you save, it will be saved automatically.

Let's check all the comments about your new article:

    [php]
    $comments = $article->getComments();

Note the plural used here in the `get` method. Propel knows that your relational model specified that an article can have several comments, so you can simply use a standard accessor to get the array of related objects. Now the `$comments` variable contains an array of objects of class `Comment`, and you can display the first one with:

    [php]
    print_r($comments[0]);

If you read comments to your articles, you might change your mind about the interest of publishing on the Internet. And if you don't appreciate the irony of article reviewers, you can easily delete the comments with the `delete()` method:

    [php]
    foreach($comments as $comment)
    {
      $comment->delete();
    }

Find more about these methods and their syntax in the [Propel documentation][4].

### Records access

If you know the primary key of a particular record, use the `retrieveByPk()` class method of the `Peer` class of the table to get the related object. For instance:

    [php]
    $article = ArticlePeer::retrieveByPk(7); 

The `schema.xml` defines the `id` field as the primary key of the `Article` table, so this statement will actually return the article that has `id` number 7. As you used the primary key, you know that only one record will be returned. So the `$article` variable contains an object of the `Article` class.

For simple queries, Propel doesn't use SQL, to allow database abstraction. Instead, it offers a `Criteria` object, which has the same power and is very easy to use.

For instance, to retrieve all articles, type:

    [php]
    $c = new Criteria();
    $articles = ArticlePeer::doSelect($c);

The class method `doSelect()` applies the selection filter received as a parameter. In this example, the `$c` object has no rules so the `doSelect()` call will return all the records of the `Article` table (it's equivalent to a '`SELECT *`' in SQL). The variable `$articles` will contain an array of all the objects of class `Article`. To access them one by one, you can simply use a `foreach` statement:

    [php]
    foreach ($articles as $article)
    {
      echo $article->getTitle();
    }

But there is more to requests than getting all records or one record by its key. The power of the `Criteria` object is that you can add rules to it, just like you would add '`WHERE`' or '`ORDER BY`' statements in a SQL query.

To get all comments written by Steve, use:

    [php]
    $c = new Criteria();
    $c->add(CommentPeer::AUTHOR, 'Steve');
    $c->addAscendingOrderByColumn(CommentPeer::DATE);
    $comments = CommentPeer::doSelect($c);

Or, because you are upset about his tone, you want all the comments not written by Steve:

    [php]
    $c = new Criteria();
    $c->add(CommentPeer::AUTHOR, 'Steve', Criteria::NOT_EQUAL);
    $c->addAscendingOrderByColumn(CommentPeer::DATE);
    $comments = CommentPeer::doSelect($c);

Note the class constants name used here: these are the phpNames of the columns in the object data model description. The `::doSelect()` method will generate the best SQL query according to your database type, execute it, and return a list of objects - which are much better than record sets. 

>**Note**: Why use `CommentPeer::AUTHOR` instead of `comment.AUTHOR`, which is the way it will be output in the SQL query? Imagine that you have to change the name of the `author` field to `contributor` in the database. If you used `comment.AUTHOR`, you would have to change it in every call to the Propel objects in your code. By using `CommentPeer::AUTHOR`, you can simply change the column name in the `schema.xml`, and keep the phpName `AUTHOR` to prevent multiple modifications.

Refer to the [Propel Documentation][5] for more details about the `Criteria` object and its methods.

Refactoring to the Data layer
-----------------------------

When developing a symfony project, you often start by writing the domain logic code in the actions. As the projects is getting more complex, the actions contain a lot of PHP and SQL code, and become less readable.

At that point, all the logic related to the data should be moved to the Model layer. Whenever you need to do the same request in more than one place in your actions, think about transferring the related code to the Model. It helps to keep the actions small and readable. 

For example, imagine the code needed in a weblog to retrieve the 10 most popular articles for a given tag (passed as request parameter). This code should not be in an action, but in the Model. As a matter of fact, if you need to display this list in a template, the action should simply look like:

    [php]
    public function executeShowPopularArticlesForTag()
    {
      $tag = TagPeer::retrieveByName($this->getRequestParameter('tag'));
      $this->articles = $tag->getPopularArticles(10);
    }

The action creates an object of class `Tag` from the request parameter. Then, all the code needed to query the database is located in a `->getPopularArticles()` method of this class. Putting the code of this method in the action would make the code much less readable.

Moving code to a more appropriate location is one of the techniques of refactoring. If you do it often, your code will be easy to maintain and to understand by other developers. A good rule of thumb about when to do refactoring to the data layer is that the code of an action should rarely count more than ten lines of PHP code.

Propel in symfony
-----------------

All the details given above are not specific to symfony. As a matter of fact, you are not obliged to use Propel as your object/relational abstraction layer. But symfony works more seamlessly with Propel, since:

* All the object data model classes and the `Criteria` classes are auto-loading classes. As soon as you will use them, symfony will include the right files, but you don't need to manually include the file inclusion.
* In symfony, Propel doesn't need to be launched nor initialized. When an object uses Propel, the library initiates by itself.
* Results of a request can be easily paginated (see more in the [pager chapter](pager.txt)).
* Propel objects allow rapid prototyping and generation of a backend for your application (see more in the [scaffolding chapter](scaffolding.txt)).

And, as Propel is independent of the database used, so is symfony.

[1]: http://propel.phpdb.org/trac/                                              "Propel"
[2]: http://propel.phpdb.org/docs/user_guide/                                   "Propel XML data model format"
[3]: http://propel.phpdb.org/docs/user_guide/chapters/GettingStarted.html       "Getting started with propel"
[4]: http://propel.phpdb.org/docs/user_guide/chapters/ManipulatingObjects.html  "Persisting objects with propel"
[5]: http://propel.phpdb.org/docs/user_guide/chapters/FindingObjects.html       "Finding objects with Propel"
[6]: http://en.wikipedia.org/wiki/CamelCase                                     "CamelCase definition at Wikipedia" 
