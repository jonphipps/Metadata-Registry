How to speed up a site with the caching system
==============================================

Overview
--------

The powerful and flexible symfony cache system can speed up a website by saving chunks of generated HTML code, or even full pages, for future requests. Easy to set up thanks to YAML files, the cache can also be cleared with a simple command.

Introduction
------------

The principle of HTML caching is simple: part or all of the HTML code that is sent to a user upon a request can be reused for a similar request, so this HTML code is stored in a special place (the `cache` folder in symfony), where the front controller will look for it before executing an action. If a cached version is found, it is sent without executing the action, thus greatly speeding up the process. If there is no cache version found, the action is executed, and its result (the view) is stored in the cache folder for future requests.

As all the pages may contain dynamic information, the HTML cache is disabled by default. It is up to the site administrator to activate it in order to improve performance.

Symfony handles three different types of HTML cache:

* cache of the result of an action
* cache of an entire page
* cache of a fragment of a template

The two first types are handled with YAML configuration files, the last one is managed by calls to helper functions in the template.

The symfony cache system uses files stored on the web server hard disk. This keeps the cache simple and efficient, without any other prerequisites than the framework itself. It is not yet possible to cache in memory or in a database.

Global cache settings
---------------------

For each application of a project, the cache mechanism can be activated or deactivated completely per environment. In the `settings.yml` configuration file, notice the `cache` parameter:

    prod:
    
    dev:
      .settings:
        ...
        cache:                  off
        ...

The default value of this parameter is set to `on`, so you have to specifically set it to `off` to disable it. It is set to `off` in the development environment to allow live modifications of the configuration.

This means that if you decide to add caching to one of your apps, you will not be able to see the effect of it in the development environment with the default configuration. The boost given by HTML caching is only perceptible in the production environment - or in any other environment where `cache:   on`.

One other cache parameter can be changed in the `settings.yml` file: The default cache lifetime, i.e. the number of seconds after which a cached file is overwritten and the page processed again. The default `default_cache_lifetime` is set to one day, or 86400 seconds.

Caching the result of an action
-------------------------------

Actions that display static information (i.e. without any call to a database) or actions that read the information in a database but without modifying it are often good clients for caching.

For instance, imagine an action that returns the list of all the users of your website (`user/list`). Unless a user is modified, added or removed (and this matter will be discussed later), this list always displays the same information, so it is a good candidate for caching.

The result of the above-mentioned action is a processed template (`listSuccess.php`), and this is what is going to be cached.

To activate the cache on such actions, simply add a `cache.yml` file in the `myproject/apps/myapp/modules/user/config/` directory, with the following content: 

    list:
      activate:   on
      type:       slot
    
    all:
      lifeTime:   86400
  
This configuration stipulates that the cache is `on` for the `list` action, and that it is of the `slot` type (i.e. caching the result of an action, as opposed to caching the whole page, which will be described later). The `lifeTime` is the time (in seconds) after which the page will be processed again and the cached version replaced. 

Now, if you try to call this action from your browser (probably by requesting an URL like `http://myapp.example.com/user/list`), you will notice no difference the first time, but refreshing the page will probably show a notable boost in response time. 

The caching system also works for pages with arguments. The `user` module may have, for instance, a `show` action that expects an `id` argument to display the details of a user. You would then just need to add the following lines at the top of the module `cache.yml` file:

    show:
      activate:   on
      type:       slot

Now, requests like `http://myapp.example.com/user/show/id/12` will create new records in the cache folder and if you repeat this request, it will be much faster the second time. 

Caching an entire page
----------------------

The final page is the combination of the template and the layout, according to the [decorator design pattern][1]. Until now, all that was written in the cache was the template, so every request ended up in a decoration process (putting the cached template into a processed layout). But if the layout has no dynamic element, you can cache the whole page instead of just the template.

Let's say this is the case for the test application described above: the layout simply contains navigation links, nothing dynamic, and can easily be cached. The cache can then be set to `page` type instead of `slot`. Modify the `cache.yml` as follows:

    show:
      activate:   on
      type:       page
      
    list:
      activate:   on
      type:       page
    
    all:
      lifeTime:   86400

If you request again the aforementioned pages:

    http://myapp.example.com/user/list
    http://myapp.example.com/user/show/id/12
    
...the full pages will be completely cached, and the second time you request them, the response will be even faster than with the action result cached.

Unfortunately, the layout often contains some dynamic elements, including [slots](view.txt). So the cases where the whole page can be cached are not very common. As a matter of fact, this type is often most used for RSS feeds, pop-ups, or pages with a layout that doesn't depend on cookies.

Caching a template fragment
---------------------------

Many times the `slot` and `page` types will be too large for the templates of an application. For instance, the list of users can show a link of the last accessed user, and this information is dynamic. Would that mean that nothing can be cached?

Thankfully not. Symfony allows you to cache fragments of a template with the `cache()` helper. The `listSuccess.php` template could be written as follows:

    [php]
    <!-- uncached HTML -->
    <?php echo link_to('last accessed user', 'user/show?id='.$last_accessed_user_id) ?>
    <!-- /uncached HTML -->
    
    <?php if (!cache('users')): ?>
      <!-- cached HTML -->
      <?php foreach ($users as $user): ?>
        <?php echo $user->getName() ?>
        ...
      <?php end foreach ?>
      <!-- /cached HTML -->
      <?php cache_save() ?>
    <?php endif ?>
    
    <!-- uncached HTML -->
    ...
    <!-- /uncached HTML -->...

Here's how it works: if a cached version of the fragment named 'users' is found, it is used to replace the code between the `<?php if (!cache('unique_fragment_name')): ?>` and the `<?php endif ?>` lines. If not, then the code between theses lines is processed and saved in the cache, identified with the unique fragment name ('users' in the example). The code not included between such lines is always processed and not cached.

Note that the `list` action must not have a `slot`- or `page`- type cache enabled, since this would bypass the whole template execution and ignore the fragment cache declaration. So either remove the `list` part of the `cache.yml` file, or write instead:

    list:
      activate:   off

After requesting twice the `http://myapp.example.com/user/list` URL, notice that the second execution is faster than the first. However, the answer is not as fast as when the cache was set to `slot` or `page`, since the template is partially processed and the decoration is made for every request.

You can declare additional fragments in the same template; however, you need to give each of them a unique name so that the symfony cache system can find them afterwards.

Like the `slot` and `page` caching, cached fragments can be given a lifetime in seconds:

    [php]
    <?php if (!cache('users', 43200)): ?>
    ...
 
The default cache lifetime (86400 seconds/one day) is used if no parameter is given to the `cache()` function.

Cache file structure
--------------------

You don't need to know how the cache files are structured to make it work, so jump to the next part if you are not a _what's-behind-the-curtain_ kind of person.

You probably noticed that each symfony project has a `cache` folder. The tree structure of its subdirectories is:

    cache/[APP_NAME]/[ENV_NAME]/
    
... in which you can find three directories, `config`, `i18n` and `template`. As mentioned in the introduction, the HTML cache is stored in the `template` directory, so for the `myapp` application in the `prod` environment, focus on the `myproject/cache/myapp/prod/template/` directory.

It contains a tree structure that matches the requested URLs. In the examples above, you requested:

    http://myapp.example.com/user/list
    http://myapp.example.com/user/show/id/12

So the tree structure of `myproject/cache/myapp/prod/template/` is:

    myapp.example.com/
      user/
        list/
        show/
          id/
            12/

That's as simple as it can be. The domain name is part of this path because you can host one app in different domains, and you don't want the cache of one domain to mess up with the others (imagine a multilingual website with different domain names like `myapp.example.com` and `myapp.example.fr`: they need distinct cache folders).

The files stored in these folders depend on the type of caching used:

cache type | file name
---------- | ---------
slot       | slot.cache
page       | page.cache
fragment   | fragment_users.cache
           | fragment_other_unique_name.cache
           | ...
      
The name given to a fragment in the `cache()` helper is concatenated after `fragment_`. Here, the second fragment was generated by:

    [php]
    <?php if (!cache('other_unique_name', SF_DEFAULT_CACHE_LIFETIME)): ?>
    ...

If you use slots in the layout, remember that their cache files are found in a tree structure relative to the module/action of the slot, not the module/action initially called.
      
Feel free to browse the cache folder to look at the chunks of code that are saved; you might feel more comfortable with the cache if you see that it only saves what it is supposed to save.

Removing something from the cache
---------------------------------

### Clearing the cache for all actions

When you modify a template or an action, you will need to clean the cache to avoid errors. The symfony command line can launch a `clear-cache` process which will erase all the cache (`config` and `i18n` included, see below). From the root folder of a project, call:

    $ symfony clear-cache
    // or use the short syntax
    $ symfony cc

In the production environment, once the cache is cleared, the first request will reprocess the configuration files and recreate the `config` cache. Then, if the HTML cache is set to on for some actions, the first call to these actions will regenerate the corresponding cache.

You may want to be more specific about what to clear:

    $ symfony clear-cache myapp
    // will erase only the cache of the myapp application
    $ symfony clear-cache myapp template
    // will erase only the HTML cache of the myapp application
    $ symfony clear-cache myapp config
    // will erase only the config cache of the myapp application
        
This is pretty straightforward, but maybe a little too drastic for some cases.

### Clearing the cache for specific actions

When the model is updated, the cache of the actions related to this model have to be cleared. Imagine that the `update` action of the `user` module modifies the columns of the `User` object. The caching of the `list` and `show` action has to be cleared, or else the old version of the templates, with erroneous data, will be displayed. This is where the `->remove()` method of the `sfViewCacheManager` object (a singleton) is useful.

In the `update` action of the `user` module, you need to add:

    [php]
    public function executeUpdate()
    {
      ...
      $this->getContext()->getViewCacheManager()->remove('user/list');
      $this->getContext()->getViewCacheManager()->remove('user/show?id='.$this->getRequestParameter('id'));
      ...
    }

The `->remove()` method expects the same kind of target as you would provide a `url_for()` helper, so it is quite easy to figure out how to clear the cached files. As an optional second argument, it accepts a type precision to target specific files:

    // removes all files
    $this->getContext()->getViewCacheManager()->remove('user/list');
    // removes only the page.cache file
    $this->getContext()->getViewCacheManager()->remove('user/list', 'page');
    // removes only the slot.cache file
    $this->getContext()->getViewCacheManager()->remove('user/list', 'slot');
    // removes only the fragment_users.cache files
    $this->getContext()->getViewCacheManager()->remove('user/list', 'fragment_users');

The trickiest part is to determine which actions are influenced by a change in an object of the model. For instance, imagine that the current application has a `publication` module where publications are listed (`list` action) and described (`show` action), along with the details of their author (an instance of the `User` class). Modifying one User record will affect all the publication descriptions of which this user is the author. This means that you need to add to the `update` action of the `user` module something like:

    [php]
    $c = new Criteria();
    $c->add(PublicationPeer::AUTHOR_ID, $this->getRequestParameter('id'));
    $publications = PublicationPeer::doSelect($c);
    
    foreach ($publications as $publication)
    {
      $this->getContext()->getViewCacheManager()->remove('publication/show?id='.$publication->getId(''));
    }
    $this->getContext()->getViewCacheManager()->remove('publication/list');

When you start using the HTML cache, you need to keep a clear view of the dependencies of the actions, so that new errors don't appear because of a misunderstood relationship. Keep in mind that all the actions that modify the model should probably contain a bunch of calls to the `->remove()` method if the HTML cache is used somewhere in the application.

### Clearing the cache of another application

If you deal with several applications and do caching in at least one of them, you will probably end up with the problem of clearing the cache of another application.

Just picture a back-office application that modifies the details of a user: all the cached pages that display the information about this user in the front-office have to be cleared, but they are in another application.

What you should do is to setup an action in the front-office application that will behave like a web service. The back-office will call this action trough HTTP, passing it the detail of the modification in the model. The web service will determine which pages need to be cleared according to the part of the model that was modified.

A tutorial will soon be published to describe this procedure.

Testing and monitoring the cache improvements
---------------------------------------------

### Staging environment

The caching system is prone to new errors in the production environment that can't be detected in the development environment, since the HTML cache is deactivated by default in development. If you use the HTML cache, it is strongly recommended to add a new environment, that will be called `staging` here, which is a copy of the production environment (thus with cache activated) but with the web debug set to on.

To set it up, edit the `settings.yml` of your application and add at the top:

    staging:
      .settings:
        web_debug:              on
        cache:                  on
        no_script_name:         off

In addition, create a new front controller by copying the production one (probably named `index.php` in the `myproject/web/` directory) to a new `myapp_staging.php` and edit it to change the `SF_ENVIRONMENT` value:

    [php]
    define('SF_ENVIRONMENT', 'staging');
    
That's it, you have a new environment. Use it by adding the front controller name after the domain name:

    http://myapp.example.com/myapp_staging.php/user/list
        
### Monitor the performance improvement

You will notice the familiar web debug box at the top right corner of the browser window, showing that the cache is set to `on`.

After a bunch of flags, this debug box also displays the process duration. Go ahead, clear the cache and make some tests: the second time you request a page, depending on the complexity of the action and template, can be several times faster with caching turned on.        

To get more details about the caching impact, activate the debug mode by editing the `myapp_staging.php` and changing the `SF_DEBUG` value:

    [php]
    define('SF_DEBUG', true);
 
Don't forget to clear the cache before requesting the page again.

Beware that the debug mode greatly decreases the speed of your application, since a lot of information is logged and made available to the web debug box. So the processed time in debug mode is not representative of what it will be when the debug mode is turned off. 

On the other hand, the web debug mode allows you to get additional information: the number of database requests needed to display the page, the ability to reload the page without caching (the middle button in the top part of the debug box) and full detail about the events encountered by the framework objects (the information bubble in the top part of the box).

### Identifying cache parts

In pages that contain cached parts (slots, page or fragments), the web_debug mode allows you to display information about each part. By clicking on the 'cache information' link, you open a detail box showing:
 
* the internal URI of the fragment,
* the lifetime of the fragment,
* the moment when it was last modified

This will help you identify problems when dealing with out-of-context fragments, to see when the fragment was created and which parts of a template you can actually cache.

Client-side caching
-------------------

An HTTP response can define, in the header, whether the content can be cached in the client browser for a specific period of time.

TO DO: ability to define client-side page caching from the cache.yml, VARY, etc.

Postscript
----------

In addition to the HTML cache, symfony has two other cache mechanisms, which are completely automated and transparent to the developer. In the production environment, the _configuration_ and the _template translations_ are cached in files stored in the `myproject/cache/config/` and `myproject/cache/i18n/` directories without any intervention. This already speeds up the delivery of pages a lot, but the most powerful feature, the HTML cache, can not be fully automated. That's why it relies on configuration and additional code.

One last word about speeding up PHP applications: [Eaccelerator][2] also increases performance of symfony PHP scripts by caching them in compiled state, so that the overhead of compiling is almost completely eliminated. This is particularly true for the [Propel][3] libraries, which contain a great amount of code. Eaccelarator is compatible with symfony, and their effects can be combined. 

[1]: http://en.wikipedia.org/wiki/Decorator_pattern     "Decorator pattern definition at Wikipedia"
[2]: http://eaccelerator.net/HomeUk                     "Eaccelerator project website"
[3]: http://propel.phpdb.org/trac/                      "Propel"
