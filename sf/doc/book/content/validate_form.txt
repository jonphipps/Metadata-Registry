How to validate a form
======================

Overview
--------

Form validation can occur on the server side and/or on the client side. The server side validation is compulsory - to avoid wrong data to corrupt a script or a database - and the client side validation is optional, though it greatly enhances the user experience. Symfony automates the server side validation to speed up the development of common web applications.

Base example
------------

Let's illustrate the validation features of Symfony starting with a normal Contact form, without any kind validation, showing the following fields:

*   name
*   email
*   age
*   message

In a newly created `contact` module, the first action to write is the one that displays the form by calling the default template:

    [php]
    class contactActions extends sfActions
    {
      public function executeIndex()
      {
        return sfView::SUCCESS;
      }
    }

And the corresponding `indexSuccess.php` template contains:

    [php]
    <?php echo form_tag('contact/send') ?>
      <label for="name">Name</label> : <?php echo input_tag('name') ?><br />
      <label for="email">Email</label> : <?php echo input_tag('email') ?><br />
      <label for="age">Age</label> : <?php echo input_tag('age') ?><br />
      <label for="message">Message</label> : <?php echo textarea_tag('message') ?><br />
      <?php echo submit_tag() ?>
    </form>

If you wonder what  the `_tag()` functions do, you should probably take a look at the [form helpers chapter](templating_form_helpers.txt). The form can now be displayed in the browser by typing the URL `index.php/contact`.

To handle the form submission, the `send` action must be created. For this example, we just need the application to display an "OK" message after submission:

    [php]
    class contactActions extends sfActions
    {
    
      ...
    
      public function executeSend()
      {
        $this->email = $this->getRequestParameter('email');
      }
    }

The `sendSuccess.php` template just contains:

    [php]
    Your message was sent to our services. The answer will be sent at <?php echo $email ?> 

You can test the whole process of submitting the form and getting the confirmation, it already works fine. Except that if you try to enter invalid data in the fields, the action may very well crash. The fields do require validation.

Rules
-----

Let's write the validation rules in plain text:

*   name: required text field, size must be between 2 and 100 characters
*   email: required text field, must contain a valid email address
*   age: required number field, must contain a integer between 0 and 120
*   message : required field

Symfony can apply these rules almost automatically, provided that you add a new configuration file to the module and change a few details in the template.

Configuration file
------------------

By convention, if you want to validate the form data on the call to the `send` action, a configuration file called `send.yml` must be created in the `validate` directory of the module. To validate only the `name` field, you need the following configuration:

    methods:
      get:            [name]
      post:           [name]
    
    names:
      name:
        required:     Yes
        required_msg: The name field cannot be left blank
        validators:   nameValidator
    
    nameValidator:
      class:          sfStringValidator
      param:
        min:          2
        min_error:    You didn't enter a valid name (at least 2 characters). Please try again.
        max:          100
        max_error:    You didn't enter a valid name (less than 100 characters). Please try again.

Let's have a closer look at this file:

First, under the `methods` header, the list of fields to be validated is defined for the method of the form (post by default). To be able to change your mind in the future,  you should double the statement for the other method.

Then, under the `names` header, the list of the the fields to be checked, along with their 'required' flag, corresponding error message and mention of any specific validation rules header, are specified.

Eventually, as the 'name' field is declared to have a specific set of validation rules, they are detailed under the corresponding header.

Action modification
-------------------

The default behavior makes symfony call a predefined `handleError` method whenever an error is detected in the validation process. This method will simply display the `sendError` template.

But if you rather need the form to be displayed again with an error message, you need to override the default `handleError` method and end it with a redirection to the `index` action of the `contact` module. Add the following code to your contact actions:

    [php]
    class ContactActions extends sfActions
    {
    
      ...
    
      public function handleError()
      {
        $this->forward('contact', 'index');
      }
    }

If you try to fill in the form with this new configuration, and type a wrong name, the form is displayed again, but the data you entered is lost and no error message explains the reason of the failure.

Template modification
---------------------

To address these two issues, you just need to modify the `indexSuccess.php` template.

Since the *forward* method kept the original request, the template has access to the data entered by the user:

    [php]
    <?php echo form_tag('contact/send') ?>
      <label for="name">Name</label> : <?php echo input_tag('name', $sf_params->get('name')) ?><br />
      <label for="email">Email</label> : <?php echo input_tag('email', $sf_params->get('email')) ?><br />
      <label for="age">Age</label> : <?php echo input_tag('age', $sf_params->get('age')) ?><br />
      <label for="message">Message</label> : <?php echo textarea_tag('message', $sf_params->get('message')) ?><br />
      <?php echo submit_tag() ?>
    </form>
    
>**Note**: You can avoid setting manually the value of the fields from the request by using a special filter. See the **Repopulation** section below.

You can detect whether the form has errors by calling the `->hasErrors()` method of the `sfRequest` object. To get the list of the error messages, you need the method `->getErrors()`. So you should add the following lines at the top of the template:

    [php]
    <?php if ($sf_request->hasErrors()): ?>
      <p>The data you entered seems to be incorrect.
      Please correct the following errors and resubmit:</p>
      <ul>
      <?php foreach($sf_request->getErrors() as $error): ?>
        <li><?php echo $error ?></li>
      <?php endforeach ?>
      </ul>
    <?php endif ?>

Now you may suggest that the field with incorrect data should be highlighted, for instance with a repetition of the error message clearly attached to the label with a ↓. To that extent, simply add the following line before every field:

    [php]
    <?php if ($sf_request->hasError('name')): ?>↓ <?php echo $request->getError('name') ?> ↓<?php endif ?><br />

Complete configuration file
---------------------------

You can add the other rules to the `send.yml` configuration file to force the validation of all fields:

    methods:
      get:      [name, email, age, message]
      post:     [name, email, age, message]
    
    names:
      name:
        required:       Yes
        required_msg:   The name field cannot be left blank
        validators:     nameValidator
      email:
        required:       Yes
        required_msg:   The name field cannot be left blank
        validators:     emailValidator
      age:
        required:       No
        validators:     ageValidator
      message:
        required:       Yes
        required_msg:   The message field cannot be left blank
    
    nameValidator:
      class:          sfStringValidator
      param:
        min:          2
        min_error:    You didn't enter a valid name (at least 2 characters). Please try again.
        max:          100
        max_error:    You didn't enter a valid name (less than 100 characters). Please try again.
    
    ageValidator:
      class:          sfNumberValidator
      param:
        nan_error:    Please enter an integer
        min:          0
        min_error:    You're not even born. How do you want to send a message ?
        max:          120
        max_error:    Hey, grandma, aren't you too old to surf on the Internet ?
    
    emailValidator:
      class:          sfRegexValidator
      param:
        match:        Yes
        match_error:  "You didn't enter a valid email address (for example: name@domain.com). Please try again."
        pattern:      /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/i

Available validators
--------------------

The available validators can be found in the symfony lib `validator` directory. For the moment, they are:

- `sfStringValidator`: allows you to apply string-related constraints to a parameter
- `sfNumberValidator`: verifies if a parameter is a number and allows you to apply size constraints
- `sfRegexValidator`: allows you to match a value against a regular expression pattern	
- `sfEmailValidator`: verifies if a parameter contains a value that qualifies as an email address 	
- `sfCompareValidator`: checks the equality of two different request parameters; very useful for password check

Let's illustrate this last validator. Imagine that you have a form with two password fields named `password1` and `password2`. The second field is there to check that the user enters the same password twice. The YAML validation file should then look like:

    methods:
      get:      [password1, password2]
      post:     [password1, password2]

    names:
      password1:
        required:       Yes
        required_msg:   Please enter a password
      password2:
        required:       Yes
        required_msg:   Please retype the password
        validators:     passwordValidator
        
    passwordValidator:
       class:            sfCompareValidator
       param:
         check:          password1
         compare_error:  The passwords you entered do not match. Please try again.

For a detailed description of the parameters of each of these validators, refer to the source code.

Custom validator
----------------

Each `Validator` is a particular class that can have certain parameters. If the validation classes shipped with Symfony are not enough for your needs, you can easily create new ones. Here is the example of a validation class for email addresses, the actually existing `sfEmailValidator`:

    [php]
    class sfEmailValidator extends sfValidator
    {
      public function execute (&$value, &$error)
      {
        if (!preg_match('~^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,3})$~i', $value))
        {
          $error = $this->getParameter('email_error');
          return false;
        }
        return true;
      }
    
      public function initialize ($context, $parameters = null)
      {
        // set defaults
        $this->setParameter('email_error', 'Invalid input');    
        // initialize parent
        parent::initialize($context, $parameters);
        return true;
      }
    }

Now the last part of the `send.yml` file can be replaced with:

    emailValidator:
      class:          sfEmailValidator
      param:
       email_error:   You didn't enter a valid email address (for example: name@domain.com). Please try again.

If you need to create a new validation class and if it is a generic one, you should ask to have it included in the framework.

Forms with array syntax
-----------------------

PHP allows you to use an array syntax for the form fields. When writing forms by yourslef, or when using the ones generated by the [Propel admin](generator.txt), you end up with HTML code looking like:

    [php]
    <label for="story[title]">Titre:</label>
    <input type="text" name="story[title]" id="story[title]" value="default value" size="45" />

The trouble is that using the input `id` as is (with brackets) in a validation file will push the YAML parser to its limits, and you will end up with errors. The solution here is to replace square brackets `[]` by curly brackets `{}` in the `names:` and `methods:` sections, and to use the explicit list declaration syntax with quotation marks for the `methods:` section:

    methods:
      get:
        - "story{title}"
      post:
        - "story{title}"
        
    names:
      story{title}:
        required:     Yes

Symfony will do the translation automatically, and the validation will run as expected.

Repopulation
------------

Note: This feature is only  available with a symfony release higher than 1096 and is still considered Alpha, since the interface can change. Feel free to give your feedback about it.

One common concern about forms is the value that the form fields will have when the form is displayed again after a failed validation. If you defined default values, or if you use object helpers, it can be quite tricky to determine how to handle the values from the request. In addition, some controls (namely the checkbox and the select tags) have special ways to pass their value in the request parameters.

Fortunately, symfony takes care of the form repopulation for you. If you want your form to be filled in with the values previously entered by the user, simply add these lines to your validation file:

    fillin:
      activate: on   # activate the form repopulation
      param:
        name: test   # name of the form

This forces you to give a `name` attribute to your form, but it opens the possibility to repopulate a form in a page that contains more than one.

The repopulation works for text and hidden inputs, textareas, radiobuttons, checkboxes and selects (simple and multiple).

You might want to transform the values entered by the user before putting them in a form input. Escaping, url rewriting, transformation of special characters into entities, etc., all the transformations that can be called through a function (existing or defined by you) can be applied to the fields of your form if you define the transformation under the `converters:` key:

     fillin:
      activate: on
      param:
        name: test
        converters:         # converters to apply
          htmlentities:     [first_name, comments]
          htmlspecialchars: [comments]

The repopulation feature is based on a filter called `sfFillInFormFilter`, and it means that you can take advantage of form repopulation even if you don't use the symfony validation files. To activate the filter, just add it to your `filters.yml` as you would do with a normal filter (see more in the [filter chapter](filters.txt)).

Client side validation
----------------------

The client side validation is done by some javascript code. Symfony will soon provide built-in client-side validation features based on the YAML validation configuration files. Make sure you get the latest version !